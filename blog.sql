-- MySQL dump 10.13  Distrib 8.2.0, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: blog
-- ------------------------------------------------------
-- Server version	8.2.0

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `admin`
--

DROP TABLE IF EXISTS `admin`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `admin` (
  `id` varchar(100) NOT NULL,
  `account` varchar(100) NOT NULL,
  `password` varchar(100) DEFAULT NULL,
  `token` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `admin`
--

LOCK TABLES `admin` WRITE;
/*!40000 ALTER TABLE `admin` DISABLE KEYS */;
INSERT INTO `admin` VALUES ('26f4b4db-922a-42f3-bb52-69528f182cae','','$2a$10$o/qWTRliOUpVL9Cmo2PLTefrWjvbOwso1zRPzAuZEC14h5.AQzvMi','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjI2ZjRiNGRiLTkyMmEtNDJmMy1iYjUyLTY5NTI4ZjE4MmNhZSIsImlhdCI6MTcxMzk1Njg0MSwiZXhwIjoxNzE0Mzg4ODQxfQ.t-vXACZZOC7ouSdd8o1gCH0_5OU34xpLXwclrZ3cdzk'),('721461b5-64e5-44d9-b2fa-b9db6373150e','helloasa','$2a$10$lM4Kaq.hI4MTNSXmoxDXw.xHh1EKK/3ciHy72tsK1QB10pULoXxfW','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjcyMTQ2MWI1LTY0ZTUtNDRkOS1iMmZhLWI5ZGI2MzczMTUwZSIsImlhdCI6MTcxMzg1OTc5OCwiZXhwIjoxNzE0MjkxNzk4fQ.zwr2YxCO6ih6AA6aOwg8f_ofXMcYbW1FMEhFOdNazQU'),('738e6948-d439-45c0-8837-2fcecc054931','aaaa','$2a$10$.eHq4zV5ygBtcB8/IUBtDOWCzCxn0rXaGBg9ala0WBOuFk.pGxAEm','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjczOGU2OTQ4LWQ0MzktNDVjMC04ODM3LTJmY2VjYzA1NDkzMSIsImlhdCI6MTcxNDExMzU2NiwiZXhwIjoxNzE0NTQ1NTY2fQ.LGIY7_eGRRe20zAAuWqNIbehrBD8aM-xIj7tOPytXeQ'),('e613bbe3-bca9-49c8-9086-e1d3b1caea4d','aaaa2','$2a$10$bGOC9HtEuFjkAYoy.u.LcOr9vaL80s4uXE3vUdGCemZYd6PNmu2dK','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImU2MTNiYmUzLWJjYTktNDljOC05MDg2LWUxZDNiMWNhZWE0ZCIsImlhdCI6MTcxMzk1NzY5OCwiZXhwIjoxNzE0Mzg5Njk4fQ.orznkTw8Zoy2SnxfsDlIQZNdcH0gNqdVFIR-1za2jxw'),('fe0e1673-ac7e-41eb-90a8-136520dab2c3','admin','$2a$10$JIA0f0EQ0eH90mDVqN6e0.vqLQ1L/yfFVM.O6rU.VN3CC9NjWnhwy','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImZlMGUxNjczLWFjN2UtNDFlYi05MGE4LTEzNjUyMGRhYjJjMyIsImlhdCI6MTcxNTYxMjQ5MCwiZXhwIjoxNzE2MDQ0NDkwfQ.Kmtz74CMcaPAMchJ02bjuIcXKS4at3LRxEmGOMONHMM');
/*!40000 ALTER TABLE `admin` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog`
--

DROP TABLE IF EXISTS `blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog` (
  `id` bigint NOT NULL,
  `category_id` bigint DEFAULT NULL,
  `title` varchar(200) DEFAULT NULL,
  `content` text,
  `create_time` bigint DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `category_id` (`category_id`),
  CONSTRAINT `category_id` FOREIGN KEY (`category_id`) REFERENCES `category` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog`
--

LOCK TABLES `blog` WRITE;
/*!40000 ALTER TABLE `blog` DISABLE KEYS */;
INSERT INTO `blog` VALUES (527377793867845,527055364431941,'今天天气真好','<p>分隔符苟富贵</p>',1706591144206),(527466826375237,527055436574789,'121323','<p>2312313123</p>',1706612880658),(527467322912837,527055387430981,'223','<p>ewwwwwwww</p>',1706613001883),(545091703509061,544814727430213,'','<p>eweqwewqewq</p>',1710915829177),(545092273590341,544065546326085,'45454','<p>123</p>',1710915968357),(545092289810501,544065546326085,'45454是的撒的','<p>123</p>',1710915972317),(545092323737669,544814727430213,'额额外','<p><br></p>',1710915980600),(545092543942725,527055436574789,'22226564565','<p>5435435435435</p>',1710916034361),(545092577919045,544814727430213,'8967564564','<p><br></p>',1710916042656),(545100835512389,544065546326085,'大大大大的撒','<p>额问问</p>',1710918058670),(545113275957317,527055364431941,'问问去而我却而我却','<p>sasaS</p>',1710921095888),(545113397620805,527055364431941,'你好啊','<p>你好啊12123213244342.</p><p><br></p><p>&lt;script&gt;alert(\"xss\");&lt;/script&gt;;</p>',1710921125591),(547652332544069,527055364431941,'xss测试','<p>&lt;h1 id=\"title\"&gt;XSS Demo&lt;/h1&gt;</p><p><br></p><p>&lt;p class=\"text-center\"&gt;</p><p>Sanitize untrusted HTML (to prevent XSS) with a configuration specified by a Whitelist.</p><p>&lt;/p&gt;</p><p><br></p><p>&lt;form&gt;</p><p> &nbsp;&lt;input type=\"text\" name=\"q\" value=\"test\"&gt;</p><p> &nbsp;&lt;button id=\"submit\"&gt;Submit&lt;/button&gt;</p><p>&lt;/form&gt;</p><p><br></p><p>&lt;pre&gt;hello&lt;/pre&gt;</p><p><br></p><p>&lt;p&gt;</p><p> &nbsp;&lt;a href=\"http://jsxss.com\"&gt;http&lt;/a&gt;</p><p> &nbsp;&lt;a href=\"https://jsxss.com\"&gt;https&lt;/a&gt;</p><p> &nbsp;&lt;a href=\"ftp://jsxss.com\"&gt;ftp&lt;/a&gt;</p><p> &nbsp;&lt;a href=\"other1\"&gt;other1&lt;/a&gt;</p><p> &nbsp;&lt;a href=\"/other2\"&gt;other2&lt;/a&gt;</p><p> &nbsp;&lt;a href=\"#\"&gt;other3&lt;/a&gt;</p><p>&lt;/p&gt;</p><p><br></p><p>&lt;h3&gt;Features:&lt;/h3&gt;</p><p>&lt;ul&gt;</p><p> &nbsp;&lt;li&gt;Specifies HTML tags and their attributes allowed with whitelist&lt;/li&gt;</p><p> &nbsp;&lt;li&gt;Handle any tags or attributes using custom function&lt;/li&gt;</p><p>&lt;/ul&gt;</p><p><br></p><p>&lt;script type=\"text/javascript\"&gt;</p><p>alert(/xss/);</p><p>&lt;/script&gt;</p><p> &nbsp; &nbsp; &nbsp;</p>',1711540982751),(549818437341253,527055364431941,'dfsdfsdf','<p><br></p>',1712069816929),(549818994950213,527055364431941,'dfsdfsdfsd','<p><img src=\"http://localhost:8080\\uploads\\c77f2f352b40139040fe9e900.jpg\" alt=\"无\" /></p>\n- 你好\n- 你好\n',1712069953064),(550078067445829,527055436574789,'复习','# React复习\n\n## 组件\n\n命名规则：必须首字母大写。\n\n返回：加括号\n\n### 默认与命名导出\n\n不鼓励使用没有名称的组件，例如 `export default () =&gt; {}`，因为它们会使调试变得更加困难。\n\n## jsx\n\nJSX 是 JavaScript 的语法扩展，可让你在 JavaScript 文件中编写类似 HTML 的标记。\n\nJSX 看起来像 HTML，但在底层它被转换为普通的 JavaScript 对象。\n\n### JSX 规则 \n\n1. 返回单个根元素: `` 和 ``\n2. 关闭所有标签:JSX 要求标记被显式闭合：像 `<img>` 这样的自闭标签一定要写成 `<img />`，像 `<li>oranges` 这样的环绕标签一定要写成 `<li>oranges</li>`。\n3. 驼峰式所有大部分内容！  由于历史原因，[`aria-*`](https://web.nodejs.cn/docs/Web/Accessibility/ARIA) 和 [`data-*`](https://web.nodejs.cn/docs/Learn/HTML/Howto/Use_data_attributes) 属性在 HTML 中用破折号书写。\n\n### 何处使用大括号 \n\n你只能在 JSX 中以两种方式使用大括号：\n\n1. 作为直接在 JSX 标签内的文本：`<h1>{name}\'s To Do List</h1>` 有效，但 `Gregorio Y. Zara\'s To Do List` 无效。\n2. 作为紧跟在 `=` 符号后面的属性：`src={avatar}` 将读取 `avatar` 变量，但 `src=\"{avatar}\"` 将传递字符串 `\"{avatar}\"`。\n\n### 使用 “双大括号”：JSX 中的 CSS 和其他对象 \n\n## props\n\n### 解构\n\n\n### 默认值\n\n```jsx\nfunction Avatar({ person, size = 100 }) {\n  // ...\n}\n```\n\n默认值仅在缺少 `size` 属性或传递 `size={undefined}` 时使用。但如果传递 `size={null}` 或 `size={0}`，则不会使用默认值。\n\n### 转发属性\n\n将Profile` 的所有属性转发给 `Avatar\n\n```jsx\nfunction Profile(props) {\n  return (\n    <div>\n      \n    </div>\n  );\n}\n```\n\n### children\n\n类似于vue中的插槽。\n\n```jsx\nimport Avatar from \'./Avatar.js\';\n\nfunction Card({ children }) {\n  return (\n    <div>\n      {children}\n    </div>\n  );\n}\n\nexport default function Profile() {\n  return (\n    \n      \n    \n  );\n}\n\n```\n\nprops 是 [不可变的](https://en.wikipedia.org/wiki/Immutable_object) 。意思是 “不可修改的”。当组件需要更改其属性时（例如，响应用户交互或新数据），它必须对其父组件进行 “询问” 才能向其传递不同的属性- 一个新对象！它的旧属性将被丢弃，最终 JavaScript 引擎将回收它们占用的内存。\n\n## 条件渲染\n\n### 使用 `null` 有条件地不返回任何内容 \n\n在某些情况下，你根本不想渲染任何东西。例如，假设你根本不想显示封装好的条目。一个组件必须返回一些东西。在这种情况下，你可以返回 `null`\n\n```jsx\nif (isPacked) {\n  return null;\n}\nreturn <li>{name}</li>;\n```\n\n### 条件（三元）运算符 (`? :`) \n\n```jsx\nreturn (\n  <li>\n    {isPacked ? name + \' ✔\' : name}\n  </li>\n);\n```\n\n### 逻辑与运算符 (`&&`) \n\n```jsx\nreturn (\n  <li>\n    {name} {isPacked && \'✔\'}\n  </li>\n);\n```\n\n前面为真时继续执行，前面为假时短路。\n\n\n\n## 渲染列表\n\n- 使用 JavaScript 的 `map()` 从数组中渲染组件\n- 使用 JavaScript 的 `filter()` 只渲染特定组件\n- 何时以及为何使用 React 键\n\n### map\n\n1、直接在 `map()` 调用中的 JSX 元素总是需要键！\n\n```jsx\n<li>...</li>\n```\n\n2、为每个列表项显示多个 DOM 节点 ,需要使用稍长的 [更明确的 `` 语法](https://react.nodejs.cn/reference/react/Fragment#rendering-a-list-of-fragments)。\n\n```jsx\nimport { Fragment } from \'react\';\n\n// ...\n\nconst listItems = people.map(person =&gt;\n  \n    <h1>{person.name}</h1>\n    <p>{person.bio}</p>\n  \n);\n```\n\n获取key:数据库返回的或者uuid等。\n\n---\n\n\n\n具体步骤：\n\n1、将数据移动到数组中：\n\n```jsx\nconst people = [\n\n  \'Creola Katherine Johnson: mathematician\',\n\n  \'Mario José Molina-Pasquel Henríquez: chemist\',\n\n  \'Mohammad Abdus Salam: physicist\',\n\n  \'Percy Lavon Julian: chemist\',\n\n  \'Subrahmanyan Chandrasekhar: astrophysicist\'\n\n];\n```\n\n2、将 `people` 成员映射到新的 JSX 节点数组 `listItems`：\n\n```jsx\nconst listItems = people.map(person =&gt; <li>{person}</li>);\n```\n\n3、从封装在 `<ul>` 中的组件返回 `listItems`：\n\n```jsx\nreturn <ul>{listItems}</ul>;\n```\n\n---\n\n### filter\n\n先过滤再遍历\n\n1、通过在 `person.profession === \'chemist\'` 过滤的 `people` 上调用 `filter()`，创建一个由“化学家”人员组成的新数组 `chemists`：\n\n```jsx\nconst chemists = people.filter(person =&gt;\n  person.profession === \'chemist\'\n);\n```\n\n2、现在映射 `chemists`：\n\n```jsx\nconst listItems = chemists.map(person =&gt;\n  <li>\n     <img src alt=\"{person.name}\" />\n     <p>\n       <b>{person.name}:</b>\n       {\' \' + person.profession + \' \'}\n       known for {person.accomplishment}\n     </p>\n  </li>\n);\n```\n\n3、最后，从组件返回 `listItems`：\n\n```jsx\nreturn <ul>{listItems}</ul>;\n```\n\n## 纯函数\n\n[纯函数](https://wikipedia.org/wiki/Pure_function) 是具有以下特性的函数：\n\n- 它只管自己的事。它不会更改调用之前存在的任何对象或变量。\n- 相同的输入，相同的输出。给定相同的输入，纯函数应该总是返回相同的结果。\n\n### 副作用：（非）预期的后果 \n\nReact 的渲染过程必须始终是纯粹的。组件应该只返回它们的 JSX，而不应该更改渲染之前存在的任何对象或变量\n\n### 严格模式\n\nReact 提供了一个 “严格模式”，它在开发过程中两次调用每个组件的函数。通过两次调用组件函数，严格模式有助于找到违反这些规则的组件。\n\n严格模式对生产没有影响，因此它不会降低用户的应用速度。要选择进入严格模式，你可以将根组件封装到 `` 中。一些框架默认这样做。\n\n### 局部突变\n\ncups数组在`TeaGathering`里面定义，并不会影响到外部数组。\n\n```jsx\nfunction Cup({ guest }) {\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaGathering() {\n  let cups = [];\n  for (let i = 1; i &lt;= 12; i++) {\n    cups.push();\n  }\n  return cups;\n}\n```\n\n### 纯函数的优点\n\n1. 组件可以在不同的环境中运行 - 例如，在服务器上\n\n2. 你可以通过 [跳过渲染](https://react.nodejs.cn/reference/react/memo) 输入未更改的组件来提高性能。这是安全的，因为纯函数总是返回相同的结果，所以它们可以安全地缓存。\n\n3. 如果在渲染深层组件树的过程中某些数据发生变化，React 可以重新开始渲染，而不会浪费时间完成过时的渲染。纯粹使你可以安全地随时停止计算。\n\n	\n\n### 哪些应该是纯的\n\n你不应该改变你的组件用于渲染的任何输入。这包括**属性(props)、状态和上下文**。---props, state, and context.要更新屏幕，[“set” 状态](https://react.nodejs.cn/learn/state-a-components-memory) 而不是改变预先存在的对象。reducer也必须是纯粹的。\n\n\n\n## 响应事件\n\n\n### 将事件处理程序作为属性传递 \n\n```jsx\nfunction Button({ onClick, children }) {\n  return (\n    \n      {children}\n    \n  );\n}\n\nfunction PlayButton({ movieName }) {\n  function handlePlayClick() {\n    alert(`Playing ${movieName}!`);\n  }\n  return (\n    \n      Play \"{movieName}\"\n    \n  );\n}\n```\n\n`PlayButton` 将 `handlePlayClick` 作为 `onClick` 属性传给里面的 `Button`。\n\n### 事件传播 \n\n阻止事件传播\n\n```jsx\n {\n      e.stopPropagation();\n      onClick();\n    }}&gt;\n      {children}\n    \n```\n\n### 默认行为\n\n1. 某些浏览器事件具有与之关联的默认行为。例如，`` 提交事件，当点击其中的按钮时发生，默认情况下将重新加载整个页面。\n2. a链接默认跳转。\n\n`e.preventDefault()`阻止了少数事件的默认浏览器行为。\n\n### 事件处理程序可以有副作用吗？ \n\n绝对地！事件处理程序是处理副作用的**最佳场所**。\n\n而渲染函数应该是纯粹的。\n\n## 状态：组件的内存\n\n[`useState`](https://react.nodejs.cn/reference/react/useState) 钩子提供了这两件事：\n\n1. 用于保留渲染之间数据的状态变量。\n2. 一个状态设置函数，用于更新变量并触发 React 再次渲染组件。\n\n```jsx\nimport { useState } from \'react\';\nconst [index, setIndex] = useState(0);\nfunction handleClick() {\n    setIndex(index + 1);\n  }\n```\n\n### 状态是隔离的和私有的\n\n状态对于屏幕上的组件实例是局部的。\n\n## 渲染和提交\n\n- React 中的渲染意味着什么\n- React 何时以及为何渲染组件\n- 在屏幕上显示组件所涉及的步骤\n- 为什么**渲染并不总是产生 DOM 更新**\n\n---\n\n组件渲染的原因有两个：\n\n1. 这是组件的初始渲染。\n2. 组件（或其祖级之一）的状态已更新。\n\n渲染必须始终为 [纯计算](https://react.nodejs.cn/learn/keeping-components-pure)：\n\n- 相同的输入，相同的输出。给定相同的输入，组件应该始终返回相同的 JSX。（当有人点西红柿沙拉时，他们不应该收到洋葱沙拉！）\n- 它只管自己的事。它不应更改渲染前存在的任何对象或变量。（一个订单不应更改任何其他人的订单。）\n\n在 “严格模式” 开发时，React 会调用每个组件的函数两次，这可以帮助表面因函数不纯而导致的错误。\n\n\n\n- React 应用中的任何屏幕更新都分三步进行：\n\n	1. 触发\n	2. 渲染\n	3. 提交\n\n- 你可以使用严格模式查找组件中的错误\n\n- 如果渲染结果与上次相同，React 不会触及 DOM，例如：\n\n	![image-20240331143609289](C:\\Users\\27786\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240331143609289.png)\n\n## 状态快照\n\n状态变量的值在渲染中永远不会改变，即使其事件处理程序的代码是异步的。在该渲染器的 `onClick` 中，即使在调用 `setNumber(number + 5)` 之后，`number` 的值仍然是 `0`。当通过调用你的组件对 UI 进行 React “拍了快照” 时，它的值为 “固定”。\n\n但是如果你想在重新渲染之前读取最新状态怎么办？你会想要使用 [状态更新函数](https://react.nodejs.cn/learn/queueing-a-series-of-state-updates)，将在下一页介绍！\n\n## 队列一系列状态更新\n\n- ”批处理” 是什么以及 React 如何使用它来处理多个状态更新\n- 如何连续对同一个状态变量应用多个更新\n\n### React 批量状态更新 \n\n在处理状态更新之前，React 会等到事件处理程序中的所有代码都已运行。这就是为什么重新渲染只发生在所有这些 `setNumber()` 调用之后。\n\n### 在下一次渲染之前多次更新相同的状态\n\n这是一个不常见的用例，但是如果你想在下一次渲染之前多次更新同一个状态变量，而不是像 `setNumber(number + 1)` 那样传递下一个状态值，你可以传递一个根据前一个状态计算下一个状态的函数到队列中，例如 `setNumber(n =&gt; n + 1)`。这是一种告诉 React “用状态值做某事” 而不是仅仅替换它的方法。\n\n```jsx\n//点击一次加三\n {\n        setNumber(n =&gt; n + 1);\n        setNumber(n =&gt; n + 1);\n        setNumber(n =&gt; n + 1);\n      }}&gt;+3\n```\n\n这里，`n =&gt; n + 1` 被称为更新器函数。当你将其传递给状态设置器时：\n\n1. 在事件处理程序中的所有其他代码运行之后，React 将此函数排队等待处理。\n2. 在下一次渲染期间，React 遍历队列并为你提供最终的更新状态。\n\n### 命名约定 \n\n通常用相应状态变量的首字母命名更新函数参数：\n\n```jsx\nsetEnabled(e =&gt; !e);\nsetLastName(ln =&gt; ln.reverse());\nsetFriendCount(fc =&gt; fc * 2);\n```\n\n### 更新\n\n```jsx\nsetPerson({\n  ...person, // Copy other fields\n  artwork: { // but replace the artwork\n    ...person.artwork, // with the same one\n    city: \'New Delhi\' // but in New Delhi!\n  }\n});\n```\n\n### 更新数组而不改变 \n\n| 操作 | 避免（改变数组）              | 更喜欢（返回新数组）                                         |\n| ---- | ----------------------------- | :----------------------------------------------------------- |\n| 添加 | `push`, `unshift`             | `concat`、`[...arr]` 展开语法 ([示例](https://react.nodejs.cn/learn/updating-arrays-in-state#adding-to-an-array)) |\n| 删除 | `pop`, `shift`, `splice`      | `filter`, `slice` ([示例](https://react.nodejs.cn/learn/updating-arrays-in-state#removing-from-an-array)) |\n| 替换 | `splice`、`arr[i] = ...` 赋值 | `map`([示例](https://react.nodejs.cn/learn/updating-arrays-in-state#replacing-items-in-an-array)) |\n| 排序 | `reverse`, `sort`             | 首先复制数组 ([示例](https://react.nodejs.cn/learn/updating-arrays-in-state#making-other-changes-to-an-array)) |\n\n#### 在数组末尾添加\n\n```jsx\nsetArtists( // Replace the state\n  [ // with a new array\n    ...artists, // that contains all the old items\n    { id: nextId++, name: name } // and one new item at the end\n  ]\n);\n```\n\n#### 在数组开头添加\n\n```js\nsetArtists([\n  { id: nextId++, name: name },\n  ...artists // Put old items at the end\n]);\n```\n\n- 删除（filter）\n- 替换  （map）\n- 插入中间（slice）\n\n```jsx\n function handleClick() {\n    const insertAt = 1; // Could be any index\n    const nextArtists = [\n      // Items before the insertion point:\n      ...artists.slice(0, insertAt),\n      // New item:\n      { id: nextId++, name: name },\n      // Items after the insertion point:\n      ...artists.slice(insertAt)\n    ];\n    setArtists(nextArtists);\n    setName(\'\');\n  }\n\n```\n\n#### 更新数组中的对象\n\n\n\n## 管理状态\n\n最后，你需要将 `tasksReducer` 连接到你的组件。从 React 导入 `useReducer` 钩子：\n\n```jsx\nimport { useReducer } from \'react\';\n```\n\n然后你可以替换 `useState`：\n\n```jsx\nconst [tasks, setTasks] =useState(initialTasks);\n```\n\n像这样使用 `useReducer`：\n\n```jsx\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n```\n\n`useReducer` 钩子与 `useState` 类似 - 你必须向它传递一个初始状态，它返回一个有状态值和设置状态的方法（在本例中为调度函数）。但这有点不同。\n\n`useReducer` 钩子有两个参数：\n\n1. reducer 函数\n2. 初始状态\n\n它返回：\n\n1. 有状态的值\n2. 调度函数（“调度” 用户操作到 reducer）\n\n```js\nimport { useReducer } from \'react\';\nimport AddTask from \'./AddTask.js\';\nimport TaskList from \'./TaskList.js\';\n\nexport default function TaskApp() {\n  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\n  function handleAddTask(text) {\n    dispatch({\n      type: \'added\',\n      id: nextId++,\n      text: text,\n    });\n  }\n\n  function handleChangeTask(task) {\n    dispatch({\n      type: \'changed\',\n      task: task,\n    });\n  }\n\n  function handleDeleteTask(taskId) {\n    dispatch({\n      type: \'deleted\',\n      id: taskId,\n    });\n  }\n\n  return (\n    \n      <h1>Prague itinerary</h1>\n      \n      \n    \n  );\n}\n\nfunction tasksReducer(tasks, action) {\n  switch (action.type) {\n    case \'added\': {\n      return [\n        ...tasks,\n        {\n          id: action.id,\n          text: action.text,\n          done: false,\n        },\n      ];\n    }\n    case \'changed\': {\n      return tasks.map((t) =&gt; {\n        if (t.id === action.task.id) {\n          return action.task;\n        } else {\n          return t;\n        }\n      });\n    }\n    case \'deleted\': {\n      return tasks.filter((t) =&gt; t.id !== action.id);\n    }\n    default: {\n      throw Error(\'Unknown action: \' + action.type);\n    }\n  }\n}\n\nlet nextId = 3;\nconst initialTasks = [\n  {id: 0, text: \'Visit Kafka Museum\', done: true},\n  {id: 1, text: \'Watch a puppet show\', done: false},\n  {id: 2, text: \'Lennon Wall pic\', done: false},\n];\n\n```\n## 管理状态\n\n最后，你需要将 `tasksReducer` 连接到你的组件。从 React 导入 `useReducer` 钩子：\n\n```jsx\nimport { useReducer } from \'react\';\n```\n\n然后你可以替换 `useState`：\n\n```jsx\nconst [tasks, setTasks] =useState(initialTasks);\n```\n\n像这样使用 `useReducer`：\n\n```jsx\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n```\n\n`useReducer` 钩子与 `useState` 类似 - 你必须向它传递一个初始状态，它返回一个有状态值和设置状态的方法（在本例中为调度函数）。但这有点不同。\n\n`useReducer` 钩子有两个参数：\n\n1. reducer 函数\n2. 初始状态\n\n它返回：\n\n1. 有状态的值\n2. 调度函数（“调度” 用户操作到 reducer）\n\n```js\nimport { useReducer } from \'react\';\nimport AddTask from \'./AddTask.js\';\nimport TaskList from \'./TaskList.js\';\n\nexport default function TaskApp() {\n  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\n  function handleAddTask(text) {\n    dispatch({\n      type: \'added\',\n      id: nextId++,\n      text: text,\n    });\n  }\n\n  function handleChangeTask(task) {\n    dispatch({\n      type: \'changed\',\n      task: task,\n    });\n  }\n\n  function handleDeleteTask(taskId) {\n    dispatch({\n      type: \'deleted\',\n      id: taskId,\n    });\n  }\n\n  return (\n    \n      <h1>Prague itinerary</h1>\n      \n      \n    \n  );\n}\n\nfunction tasksReducer(tasks, action) {\n  switch (action.type) {\n    case \'added\': {\n      return [\n        ...tasks,\n        {\n          id: action.id,\n          text: action.text,\n          done: false,\n        },\n      ];\n    }\n    case \'changed\': {\n      return tasks.map((t) =&gt; {\n        if (t.id === action.task.id) {\n          return action.task;\n        } else {\n          return t;\n        }\n      });\n    }\n    case \'deleted\': {\n      return tasks.filter((t) =&gt; t.id !== action.id);\n    }\n    default: {\n      throw Error(\'Unknown action: \' + action.type);\n    }\n  }\n}\n\nlet nextId = 3;\nconst initialTasks = [\n  {id: 0, text: \'Visit Kafka Museum\', done: true},\n  {id: 1, text: \'Watch a puppet show\', done: false},\n  {id: 2, text: \'Lennon Wall pic\', done: false},\n];\n\n```\n\n使用 `useReducer`，你可以在 reducer 中添加一个控制台日志，以查看每个状态更新，以及它发生的原因（由于哪个 `action`）。如果每个 `action` 都是正确的，你就会知道错误出在 reducer 逻辑本身。但是，与 `useState` 相比，你必须逐步执行更多代码。\n\n\n\n编写 reducer 时请牢记这两个提示：\n\n- **Reducer 必须是纯粹的。**与 [状态更新函数](https://react.nodejs.cn/learn/queueing-a-series-of-state-updates) 类似，reducer 在渲染过程中运行！（操作会排队直到下一次渲染。）这意味着 reducer [必须是纯的](https://react.nodejs.cn/learn/keeping-components-pure) - 相同的输入总是产生相同的输出。它们不应该发送请求、安排超时或执行任何副作用（影响组件外部事物的操作）。它们应该无突变地更新 [对象](https://react.nodejs.cn/learn/updating-objects-in-state) 和 [数组](https://react.nodejs.cn/learn/updating-arrays-in-state)。\n- 每个操作都描述了一次用户交互，即使这会导致数据发生多次更改。例如，如果用户在具有由 reducer 管理的五个字段的表单上按 “重置”，则分派一个 `reset_form` 操作比分派五个单独的 `set_field` 操作更有意义。如果你记录 reducer 中的每个操作，那么该日志应该足够清晰，以便你重建以何种顺序发生的交互或响应。这有助于调试！\n\n---\n\n## Context\n\nContext 允许父组件向其下面的树中的任何组件提供一些信息（无论多深），而无需通过属性显式传递。\n\n---\n\n复习：\n\n父子组件通信：props和自定义事件(vue里的说法，react里面是把函数以props的形式传递。)\n\n兄弟组件通信：状态提升。\n\n---\n\n​	**Context**\n\n1. 创建一个上下文。（你可以将其称为 `LevelContext`，因为它用于标题级别。）\n\n2. 使用需要数据的组件中的上下文。（`Heading` 将使用 `LevelContext`。）\n\n3. 从指定数据的组件提供上下文。（`Section` 将提供 `LevelContext`。）\n\n	\n\n步骤 1：创建上下文 \n\n`LevelContext.js`\n\n```jsx\nimport { createContext } from \'react\';\n//createContext 的唯一参数是默认值。\nexport const LevelContext = createContext(1);\n```\n\n步骤 2：使用上下文 \n\n从 React 和你的上下文中导入 `useContext` 钩子：\n\n```js\nimport { useContext } from \'react\';\nimport { LevelContext } from \'./LevelContext.js\';\n```\n\n### 从同一组件使用和提供上下文 \n\n```jsx\nimport { useContext } from \'react\';\nimport { LevelContext } from \'./LevelContext.js\';\n\nexport default function Section({ children }) {\n  const level = useContext(LevelContext);\n  return (\n    <section>\n      \n        {children}\n      \n    </section>\n  );\n}\n```\n\n### 上下文用例 \n\n- 主题：例如夜间模式）。\n- 当前账户(当前登录的用户)\n- 路由大多数路由解决方案在内部使用上下文来保存当前路由。\n- 管理状态\n\n## 使用引用引用值 \n\n当你想要一个组件给 “记住” 一些信息，但你不想让这些信息 [触发新渲染](https://react.nodejs.cn/learn/render-and-commit)，你可以使用一个引用。通过 `ref.current` 属性访问该引用的当前值。\n\n引用就像 React 不跟踪的组件的秘密口袋。例如，你可以使用引用来存储 [超时 ID](https://web.nodejs.cn/en-US/docs/Web/API/setTimeout#return_value)、[DOM 元素](https://web.nodejs.cn/en-US/docs/Web/API/Element) 和其他不影响组件渲染输出的对象。\n\n```jsx\nimport { useRef } from \'react\';\nconst ref = useRef(0);\n//访问\nref.current = ref.current + 1;\n//....\n return (\n    \n      \n      \n        Focus the input\n      \n    \n  );\n}\n```\n\n| 引用                                                    | 状态                                                         |\n| ------------------------------------------------------- | ------------------------------------------------------------ |\n| `useRef(initialValue)` 返回 `{ current: initialValue }` | `useState(initialValue)` 返回状态变量的当前值和状态设置函数 (`[value, setValue]`) |\n| 更改时不会触发重新渲染。                                | 当你更改它时，触发器会重新渲染。                             |\n| 可变 - 你可以在渲染过程之外修改和更新 `current` 的值。  | “不变的”—你必须使用状态设置功能来修改状态变量以对重新渲染进行排队。 |\n| 你不应在渲染期间读取（或写入）`current` 值。            | 你可以随时读取状态。但是，每个渲染器都有自己的 [快照](https://react.nodejs.cn/learn/state-as-a-snapshot) 状态，不会改变。 |\n\n### 何时使用ref\n\n- 存储 [超时 ID](https://web.nodejs.cn/docs/Web/API/setTimeout)\n- 存储和操作DOM 元素\n- 存储计算 JSX 不需要的其他对象。\n\n### 最佳实践 \n\n- 将引用视为应急方案。当你使用外部系统或浏览器 API 时，引用很有用。如果你的大部分应用逻辑和数据流都依赖于引用，你可能需要重新考虑你的方法。\n- 不要在渲染过程中读取或写入 `ref.current`。如果在渲染过程中需要一些信息，请改用 [状态](https://react.nodejs.cn/learn/state-a-components-memory)。由于 React 不知道 `ref.current` 何时更改，即使在渲染时读取它也会使组件的行为难以预测。（唯一的例外是像 `if (!ref.current) ref.current = new Thing()` 这样的代码，它在第一次渲染期间只设置一次引用。）\n\n### 访问另一个组件的 DOM 节点 \n\n默认情况下会报错，解决方法：\n\n1. `` 告诉 React 将相应的 DOM 节点放入 `inputRef.current` 中。但是，由 `MyInput` 组件选择是否加入该选项 - 默认情况下，它不会。\n2. `MyInput` 组件使用 `forwardRef` 声明。这选择它从上面接收 `inputRef` 作为在 `props` 之后声明的第二个 `ref` 参数。\n3. `MyInput` 本身将它收到的 `ref` 传递给它内部的 ``。\n\n```jsx\nimport { forwardRef, useRef } from \'react\';\n\nconst MyInput = forwardRef((props, ref) =&gt; {\n  return ;\n});\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    \n      \n      \n        Focus the input\n      \n    \n  );\n}\n\n```\n\n\n\n### 当 React 附加引用时 \n\n在 React 中，每个更新都拆分为 [两个阶段](https://react.nodejs.cn/learn/render-and-commit#step-3-react-commits-changes-to-the-dom)：\n\n- 在**渲染**期间，React 调用你的组件来确定屏幕上应该显示什么。\n- 在**提交**期间，React 将更改应用于 DOM。\n\n通常，你 [不希望](https://react.nodejs.cn/learn/referencing-values-with-refs#best-practices-for-refs) 在渲染期间访问引用。这也适用于持有 DOM 节点的引用。在第一次渲染期间，DOM 节点尚未创建，因此 `ref.current` 将为 `null`。并且在渲染更新期间，DOM 节点还没有更新。所以现在读取它们还为时过早。\n\nReact 在提交期间设置 `ref.current`。在更新 DOM 之前，React 将受影响的 `ref.current` 值设置为 `null`。更新 DOM 后，React 立即将它们设置为相应的 DOM 节点。\n\n通常，你将从事件处理程序访问引用。如果你想用引用做一些事情，但没有特定的事件可以做，你可能需要一个副作用。\n\n切记：更新DOM是在渲染之后。\n\n## 副作用\n\n- 渲染函数必须是纯粹的。\n- 事件处理函数可以有副作用。\n\n```jsx\n//声明副作用\nimport { useEffect } from \'react\';\nuseEffect(() =&gt; {\n    // Code here will run after *every* render\n  },[里面放依赖]);\n```\n\n如操作dom结点的逻辑可以放在useEffect里面。\n\n```jsx\nuseEffect(() =&gt; {\n\n  // This runs after every render\n\n});\n\nuseEffect(() =&gt; {\n\n  // This runs only on mount (when the component appears)\n\n}, []);\n\nuseEffect(() =&gt; {\n\n  // This runs on mount *and also* if either a or b have changed since the last render\n\n}, [a, b]);\n```\n\n\n### 不适合使用effect\n\n\n\n1、当结果可以从现有的属性或状态中计算出来时，在渲染过程中计算它。\n\n```jsx\nfunction Form() {\n\n  const [firstName, setFirstName] = useState(\'Taylor\');\n\n  const [lastName, setLastName] = useState(\'Swift\');\n\n  // Good: calculated during rendering\n\n  const fullName = firstName + \' \' + lastName;\n\n  // ...\n\n}\n```\n\n当某些东西可以从现有的属性或状态中计算出来时， [不要把它放在状态。](https://react.nodejs.cn/learn/choosing-the-state-structure#avoid-redundant-state) 而是，在渲染过程中计算它。这使你的代码更快（你避免了额外的 “层叠” 更新）、更简单（你删除了一些代码）和更不容易出错（你避免了由于不同状态变量彼此不同步而导致的错误）。如果你觉得这种方法很新，[在 React 中思考](https://react.nodejs.cn/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state) 解释了应该进入状态的内容。\n\n2、昂贵的计算\n\n你可以通过将昂贵的计算封装在 [`useMemo`](https://react.nodejs.cn/reference/react/useMemo) 钩子中来缓存（或 [“记忆化”](https://en.wikipedia.org/wiki/Memoization)）昂贵的计算：\n\n```jsx\nimport { useMemo, useState } from \'react\';\nfunction TodoList({ todos, filter }) {\n  const [newTodo, setNewTodo] = useState(\'\');\n  const visibleTodos = useMemo(() =&gt; {\n    // Does not re-run unless todos or filter change\n    return getFilteredTodos(todos, filter);\n  }, [todos, filter]);\n  // ...\n}\n```\n\n这告诉 React 你不希望内部函数重新运行，除非 `todos` 或 `filter` 发生变化。React 会在初始渲染时记住 `getFilteredTodos()` 的返回值。在下一次渲染期间，它将检查 `todos` 或 `filter` 是否不同。如果它们与上次相同，则 `useMemo` 将返回它存储的最后一个结果。但如果它们不同，React 将再次调用内部函数（并存储其结果）。\n\n\n\n### 当属性改变时重置所有状态 \n\n这个 `ProfilePage` 组件接收一个 `userId` 属性。该页面包含评论输入，你使用 `comment` 状态变量来保存它的值。有一天，你注意到一个问题：当你从一个配置文件导航到另一个配置文件时，`comment` 状态不会重置。因此，很容易不小心在错误的用户个人资料上发表评论。要解决此问题，你需要在 `userId` 更改时清除 `comment` 状态变量：\n\n```\nexport default function ProfilePage({ userId }) {\n\n  const [comment, setComment] = useState(\'\');\n\n\n\n  // Avoid: Resetting state on prop change in an Effect\n\n  useEffect(() =&gt; {\n\n    setComment(\'\');\n\n  }, [userId]);\n\n  // ...\n\n}\n```\n\n这是低效的，因为 `ProfilePage` 及其子项将首先使用旧值进行渲染，然后再次渲染。它也很复杂，因为你需要在 `ProfilePage` 中具有某种状态的每个组件中执行此操作。例如，如果评论 UI 是嵌套的，你也想清除嵌套的评论状态。\n\n而是，你可以通过给 React 一个明确的键来告诉 React 每个用户的个人资料在概念上是不同的个人资料。将你的组件一分为二，并将 `key` 属性从外部组件传递到内部组件：\n\n```jsx\nexport default function ProfilePage({ userId }) {\n\n  return (\n\n    \n\n  );\n\n}\n\n\n\nfunction Profile({ userId }) {\n\n  // This and any other state below will reset on key change automatically\n\n  const [comment, setComment] = useState(\'\');\n\n  // ...\n\n}\n```\n\n通常，当同一个组件在同一个地方渲染时，React 会保留状态。通过将 `userId` 作为 `key` 传递给 `Profile` 组件，你要求 React 将具有不同 `userId` 的两个 `Profile` 组件视为不应共享任何状态的两个不同组件。每当键（你已设置为 `userId`）更改时，React 将重新创建 `Profile` 组件及其所有子级的 DOM 和 [重置状态](https://react.nodejs.cn/learn/preserving-and-resetting-state#option-2-resetting-state-with-a-key)。现在，在配置文件之间导航时，`comment` 字段将自动清除。\n\n请注意，在此示例中，只有外部 `ProfilePage` 组件被导出并对项目中的其他文件可见。渲染 `ProfilePage` 的组件不需要将键传递给它：它们通过 `userId` 作为常规属性。`ProfilePage` 将其作为 `key` 传递给内部 `Profile` 组件的事实是一个实现细节。\n\n---\n\n造成副作用的逻辑放在哪里？\n\n如果此逻辑是由特定交互引起的，请将其保留在事件处理程序中。如果是用户在屏幕上看到组件造成的，就把它留在副作用中。\n\n---\n\n记录访问是与连接不同的过程。将它们写成两个独立的副作用。\n\n**代码中的每个副作用都应该代表一个单独且独立的同步过程。**\n\n空的 `[]` 依赖数组意味着这个副作用只有在组件挂载时才连接到聊天室，只有在组件卸载时才断开连接。\n\n### 组件主体中声明的所有变量都是反应式的 \n\n\n\n属性和状态不是唯一的 React 值。你从中计算出的值也是 React 性的。如果属性或状态发生变化，你的组件将重新渲染，并且从中计算出的值也会发生变化。这就是为什么副作用使用的组件主体中的所有变量都应该在副作用依赖列表中的原因。\n\n个人理解是使用proxy进行代理的\n\n---\n\n副作用：用于自动的副作用\n\n事件处理函数：主动的副作用\n\n---\n\n### 声明一个副作用事件 \n\n使用一个名为 [`useEffectEvent`](https://react.nodejs.cn/reference/react/experimental_useEffectEvent) 的特殊钩子从副作用中提取这种非响应式逻辑。\n\n```jsx\nimport { useEffect, useEffectEvent } from \'react\';\n\nfunction ChatRoom({ roomId, theme }) {\n  const onConnected = useEffectEvent(() =&gt; {\n    showNotification(\'Connected!\', theme);\n  });\n  // ...\n```\n\n副作用事件的使用方式非常有限：\n\n- **只能从副作用内部调用它们。**\n- **永远不要将它们传递给其他组件或钩子。**\n\n\n\n\n\n\n\n\n\n\n\n---\n\n## 自定义钩子\n\n自定义hook：以use开头，可以调用钩子。\n\n普通函数：不可以调用钩子。\n\n---\n\n1、自定义钩子让你共享状态逻辑，而不是状态本身 \n\n2、自定义钩子需要纯粹。自定义钩子与你的组件一起重新渲染，所以它们总是收到最新的属性和状态。1\n\n',1712133203185),(551184968101957,527055364431941,'4_61212','12343434**43423**fdf erer erer ✅',1712403442603),(551211317657669,527055364431941,'sdddd','∷',1712409875600),(551211400810565,527055364431941,'nihao ','∷✅',1712409895901),(553624316411973,527055364431941,'wee呃呃','问问为额我 ',1712998986624),(553624820482117,527055387430981,'tupian','![](http://localhost:8080/uploads\\426d09ef08f1de61c170e5e00.jpg)![](http://localhost:8080/uploads/426d09ef08f1de61c170e5e08.jpg)\n\n![1111](http://localhost:8080/uploads/7e1253f8e330f8b40f1f9c701.jpg)\n\n```\n![图片](https://cn.bing.com/images/search?q=%E5%9B%BE%E7%89%87jpg&FORM=IQFRBA&id=4929EB0212CFAC8CB6AB59DB53A9D2D99C54FF6A)\n\n23232323213\n![图片](https://imzbf.github.io/md-editor-rt/imgs/mark_emoji.gif)dasdadasddasdas',1712999109688);
/*!40000 ALTER TABLE `blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `category` (
  `id` bigint NOT NULL,
  `name` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (527055364431941,'知识点'),(527055387430981,'算法'),(527055436574789,'react'),(544065546326085,'英语'),(544814727430213,'2323'),(558486012620869,'rerwer'),(558486223675461,'fgdfg'),(558487186391109,'rwer wer');
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `comments` (
  `id` bigint NOT NULL COMMENT '评论的id',
  `value` text NOT NULL COMMENT '评论的内容',
  `article_id` bigint NOT NULL COMMENT '关联的文章id',
  `user` varchar(50) NOT NULL COMMENT '评论的用户名',
  `create_time` bigint DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id` (`id`),
  KEY `article_id` (`article_id`),
  CONSTRAINT `article_id` FOREIGN KEY (`article_id`) REFERENCES `blog` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
INSERT INTO `comments` VALUES (555740162670661,'123',527377793867845,'你好凄凄切切',1713515550652),(556069912051781,'初显成效正常',527377793867845,'吃 吃',1713596055873),(556069984108613,'2323',527377793867845,'434v',1713596073464),(556070526943301,'长得',527377793867845,'的 ',1713596205992),(556070782775365,'认为微软',527377793867845,'二二',1713596268451),(564329161179205,'1',553624820482117,'1',1715612474116);
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-05-13 23:03:25
